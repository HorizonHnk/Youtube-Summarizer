const express = require('express')
const cors = require('cors')
require('dotenv').config()
const axios = require('axios')

const { GoogleGenerativeAI } = require('@google/generative-ai')

const app = express()
const PORT = process.env.PORT || 5000

app.use(cors())
app.use(express.json())

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY)
const YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY

// Extract video ID from YouTube URL
function extractVideoId(url) {
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
  const match = url.match(regExp)
  return (match && match[2].length === 11) ? match[2] : null
}

// Get YouTube video metadata using YouTube Data API
async function getVideoMetadata(videoId) {
  try {
    if (!YOUTUBE_API_KEY) {
      throw new Error('YouTube API key not configured')
    }

    const response = await axios.get(`https://www.googleapis.com/youtube/v3/videos`, {
      params: {
        part: 'snippet,statistics,contentDetails',
        id: videoId,
        key: YOUTUBE_API_KEY
      }
    })

    if (response.data.items && response.data.items.length > 0) {
      const video = response.data.items[0]
      return {
        title: video.snippet.title,
        description: video.snippet.description || '',
        channelTitle: video.snippet.channelTitle,
        publishedAt: video.snippet.publishedAt,
        tags: video.snippet.tags || [],
        categoryId: video.snippet.categoryId,
        viewCount: video.statistics.viewCount,
        likeCount: video.statistics.likeCount,
        commentCount: video.statistics.commentCount,
        duration: video.contentDetails.duration,
        thumbnails: video.snippet.thumbnails,
        defaultLanguage: video.snippet.defaultLanguage || 'en',
        defaultAudioLanguage: video.snippet.defaultAudioLanguage || 'en'
      }
    }
    
    throw new Error('Video not found')
  } catch (error) {
    console.error('YouTube API error:', error.response?.data || error.message)
    throw new Error(`Failed to fetch video metadata: ${error.message}`)
  }
}

// Get available captions using YouTube Data API
async function getAvailableCaptions(videoId) {
  try {
    if (!YOUTUBE_API_KEY) {
      console.log('âš ï¸ YouTube API key not available for captions')
      return []
    }

    const response = await axios.get(`https://www.googleapis.com/youtube/v3/captions`, {
      params: {
        part: 'snippet',
        videoId: videoId,
        key: YOUTUBE_API_KEY
      }
    })

    if (response.data.items && response.data.items.length > 0) {
      console.log(`ğŸ“ Found ${response.data.items.length} caption tracks`)
      return response.data.items.map(item => ({
        id: item.id,
        language: item.snippet.language,
        name: item.snippet.name,
        isAutoSynced: item.snippet.isAutoSynced,
        trackKind: item.snippet.trackKind,
        isCC: item.snippet.isCC,
        isDraft: item.snippet.isDraft
      }))
    }

    return []
  } catch (error) {
    console.error('Captions API error:', error.response?.data || error.message)
    return []
  }
}

// Download caption content using YouTube Data API
async function downloadCaptionContent(captionId) {
  try {
    if (!YOUTUBE_API_KEY) {
      throw new Error('YouTube API key required for caption download')
    }

    const response = await axios.get(`https://www.googleapis.com/youtube/v3/captions/${captionId}`, {
      params: {
        key: YOUTUBE_API_KEY,
        tfmt: 'srt' // Request SRT format for timestamps
      }
    })

    return response.data
  } catch (error) {
    console.error('Caption download error:', error.response?.data || error.message)
    throw error
  }
}

// Enhanced transcript function with official YouTube API fallback
async function getVideoTranscript(videoId) {
  try {
    console.log('ğŸ“ Attempting to get transcript for:', videoId)
    
    // Method 1: Try official YouTube Captions API
    try {
      const availableCaptions = await getAvailableCaptions(videoId)
      
      if (availableCaptions.length > 0) {
        // Prioritize manual captions over auto-generated
        const manualCaption = availableCaptions.find(cap => !cap.isAutoSynced)
        const preferredCaption = manualCaption || availableCaptions[0]
        
        console.log(`ğŸ“ Using ${preferredCaption.isAutoSynced ? 'auto-generated' : 'manual'} captions in ${preferredCaption.language}`)
        
        const captionContent = await downloadCaptionContent(preferredCaption.id)
        
        // Parse SRT format and extract text
        const textContent = parseSRTContent(captionContent)
        
        return {
          content: textContent,
          source: 'youtube_api',
          language: preferredCaption.language,
          isAutoGenerated: preferredCaption.isAutoSynced,
          hasTimestamps: true
        }
      }
    } catch (apiError) {
      console.log('âš ï¸ YouTube Captions API failed, trying fallback method')
    }

    // Method 2: Fallback to youtube-transcript library
    try {
      const { YoutubeTranscript } = require('youtube-transcript')
      const transcript = await YoutubeTranscript.fetchTranscript(videoId)
      
      const textContent = transcript.map(item => item.text).join(' ')
      
      return {
        content: textContent,
        source: 'youtube_transcript_library',
        language: 'unknown',
        isAutoGenerated: true,
        hasTimestamps: false
      }
    } catch (libraryError) {
      console.error('YouTube transcript library error:', libraryError.message)
    }

    // Method 3: No transcript available
    return null

  } catch (error) {
    console.error('Transcript error:', error.message)
    return null
  }
}

// Parse SRT content to extract text
function parseSRTContent(srtContent) {
  if (!srtContent) return ''
  
  // Split by subtitle blocks
  const blocks = srtContent.split('\n\n')
  const textLines = []
  
  blocks.forEach(block => {
    const lines = block.trim().split('\n')
    if (lines.length >= 3) {
      // Skip sequence number (line 0) and timestamp (line 1)
      // Extract text content (lines 2+)
      const textContent = lines.slice(2).join(' ').trim()
      if (textContent) {
        textLines.push(textContent)
      }
    }
  })
  
  return textLines.join(' ')
}

// Format duration from YouTube format (PT4M13S) to readable format
function formatDuration(duration) {
  if (!duration) return 'Unknown'
  const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/)
  if (!match) return duration
  
  const hours = (match[1] || '').replace('H', '')
  const minutes = (match[2] || '').replace('M', '')
  const seconds = (match[3] || '').replace('S', '')
  
  let result = ''
  if (hours) result += `${hours}h `
  if (minutes) result += `${minutes}m `
  if (seconds) result += `${seconds}s`
  
  return result.trim() || duration
}

// Clean and format the AI response
function cleanFormatting(text) {
  return text
    // Remove markdown bold formatting
    .replace(/\*\*([^*]+)\*\*/g, '$1')
    // Remove triple asterisks
    .replace(/\*\*\*/g, '')
    // Clean up emoji headers that have asterisks
    .replace(/(ğŸ¬|ğŸ¯|ğŸ”‘|ğŸ’¡|ğŸ‘¥|ğŸ“š|â­|ğŸ“‹)\s*\*+([^*]+)\*+/g, '$1 $2')
    // Clean up any remaining asterisks at line endings
    .replace(/\*+$/gm, '')
    // Clean up multiple spaces
    .replace(/\s+/g, ' ')
    // Clean up multiple newlines
    .replace(/\n{3,}/g, '\n\n')
    // Trim each line
    .split('\n').map(line => line.trim()).join('\n')
    // Remove any remaining standalone asterisks
    .replace(/^\*+\s*/gm, '')
    .trim()
}

app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'YouTube Summarizer API is running',
    timestamp: new Date().toISOString(),
    geminiApiKeyExists: !!process.env.GEMINI_API_KEY,
    youtubeApiKeyExists: !!process.env.YOUTUBE_API_KEY,
    features: ['Real video metadata', 'Enhanced captions support', 'AI analysis', 'Clean formatting'],
    developer: {
      name: 'NGOY HENOCK MUKONKOLE',
      email: 'hhnk3693@gmail.com',
      github: 'https://github.com/HorizonHnk/Youtube-Summarizer.git',
      youtube: 'https://www.youtube.com/playlist?list=PLrZbkNpNVSwwEIPRtoMxEy14_2DFuMM8k'
    }
  })
})

app.post('/api/summarize', async (req, res) => {
  try {
    const { youtube_link, model, additional_prompt } = req.body

    if (!youtube_link) {
      return res.status(400).json({ error: 'YouTube link is required' })
    }

    const videoId = extractVideoId(youtube_link)
    if (!videoId) {
      return res.status(400).json({ error: 'Invalid YouTube URL' })
    }

    console.log('ğŸ¬ Processing video ID:', videoId)

    // Get both metadata and enhanced transcript in parallel
    const [metadata, transcriptData] = await Promise.all([
      getVideoMetadata(videoId).catch(err => {
        console.error('Metadata fetch failed:', err.message)
        return { title: 'Title unavailable', description: 'Metadata unavailable', channelTitle: 'Unknown' }
      }),
      getVideoTranscript(videoId).catch(err => {
        console.error('Transcript fetch failed:', err.message)
        return null
      })
    ])

    console.log('ğŸ“Š Video title:', metadata.title)
    console.log('ğŸ“ Transcript info:', transcriptData ? {
      source: transcriptData.source,
      language: transcriptData.language,
      isAutoGenerated: transcriptData.isAutoGenerated,
      hasTimestamps: transcriptData.hasTimestamps,
      length: transcriptData.content?.length || 0
    } : 'No transcript available')

    // Build comprehensive prompt with enhanced transcript info
    let prompt = `Please analyze this YouTube video using the following information:

**VIDEO DETAILS:**
â€¢ Title: ${metadata.title}
â€¢ Channel: ${metadata.channelTitle}
â€¢ Duration: ${formatDuration(metadata.duration)}
â€¢ Views: ${metadata.viewCount ? Number(metadata.viewCount).toLocaleString() : 'Unknown'}
â€¢ Published: ${metadata.publishedAt ? new Date(metadata.publishedAt).toLocaleDateString() : 'Unknown'}
â€¢ Likes: ${metadata.likeCount ? Number(metadata.likeCount).toLocaleString() : 'Unknown'}

**DESCRIPTION:**
${metadata.description ? metadata.description.substring(0, 1000) + (metadata.description.length > 1000 ? '...' : '') : 'No description available'}

${metadata.tags && metadata.tags.length > 0 ? `**TAGS:** ${metadata.tags.slice(0, 10).join(', ')}` : ''}

${transcriptData ? `**VIDEO TRANSCRIPT:**
Source: ${transcriptData.source === 'youtube_api' ? 'Official YouTube Captions API' : 'YouTube Transcript Library'}
Language: ${transcriptData.language}
Type: ${transcriptData.isAutoGenerated ? 'Auto-generated' : 'Manual captions'}
Timestamps: ${transcriptData.hasTimestamps ? 'Available' : 'Not available'}

Content:
${transcriptData.content.substring(0, 6000)}${transcriptData.content.length > 6000 ? '...(transcript continues)' : ''}` : '**TRANSCRIPT:** Not available (video may not have captions)'}

**ANALYSIS REQUEST:**
Based on the above information, please provide a comprehensive analysis with the following structure:

ğŸ¬ Video Overview
What is this video about? What's the main topic?

ğŸ¯ Purpose & Goals
What is the creator trying to achieve or teach?

ğŸ”‘ Key Points & Takeaways
List the most important points discussed (based on transcript if available)

ğŸ’¡ Main Insights & Lessons
What are the key insights viewers will gain?

ğŸ‘¥ Target Audience
Who would benefit most from watching this video?

ğŸ“š Content Type & Style
Educational, entertainment, tutorial, review, etc.

â­ Value Proposition
What specific value does this video provide?

ğŸ“‹ Summary
Provide a comprehensive summary of the content

IMPORTANT FORMATTING RULES:
- Use clear section headers with emojis (ğŸ¬ Video Overview, not **Video Overview**)
- Write in plain text without markdown formatting
- Do not use asterisks for bold text
- Use bullet points with â€¢ or - for lists
- Keep content clear and readable
- Write complete sentences and paragraphs`

    if (additional_prompt && additional_prompt.trim()) {
      prompt += `\n\n**SPECIAL INSTRUCTIONS:** ${additional_prompt}`
    }

    // Configure model
    const modelName = model || "gemini-1.5-flash"
    const genModel = genAI.getGenerativeModel({ model: modelName })

    let generationConfig = {
      temperature: 0.7,
      topP: 0.8,
      maxOutputTokens: 3000,
    }

    console.log('ğŸ¤– Generating analysis with model:', modelName)
    
    const result = await genModel.generateContent(prompt, { generationConfig })
    const response = await result.response
    let summary = response.text()

    // Clean up the formatting
    const cleanedSummary = cleanFormatting(summary)
    console.log('ğŸ§¹ Cleaned summary formatting')

    console.log('âœ… Analysis generated successfully')

    res.json({ 
      success: true, 
      summary: cleanedSummary,
      model_used: modelName,
      video_url: youtube_link,
      video_id: videoId,
      video_metadata: {
        title: metadata.title,
        channel: metadata.channelTitle,
        duration: formatDuration(metadata.duration),
        views: metadata.viewCount,
        likes: metadata.likeCount,
        published: metadata.publishedAt
      },
      transcript_info: transcriptData ? {
        source: transcriptData.source,
        language: transcriptData.language,
        is_auto_generated: transcriptData.isAutoGenerated,
        has_timestamps: transcriptData.hasTimestamps,
        length: transcriptData.content?.length || 0
      } : null,
      analysis_quality: {
        has_metadata: !!metadata.title,
        has_transcript: !!transcriptData,
        transcript_source: transcriptData?.source || 'none',
        transcript_length: transcriptData?.content?.length || 0,
        content_richness: transcriptData ? 'High' : 'Medium',
        formatting_cleaned: true
      },
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('âŒ Error:', error)
    
    if (error.message.includes('API_KEY')) {
      return res.status(401).json({ 
        error: 'API key issue',
        details: error.message
      })
    }
    
    if (error.message.includes('quota')) {
      return res.status(429).json({ 
        error: 'API quota exceeded',
        details: 'YouTube API or Gemini API quota limit reached. Try again later or switch models.'
      })
    }

    if (error.response?.status === 429) {
      return res.status(429).json({ 
        error: 'Rate limit exceeded',
        details: 'Too many requests. Please wait a moment before trying again.'
      })
    }
    
    res.status(500).json({ 
      error: 'Failed to analyze video',
      details: error.message 
    })
  }
})

app.use((req, res) => {
  res.status(404).json({ 
    error: 'Route not found',
    available_routes: ['GET /api/health', 'POST /api/summarize']
  })
})

app.listen(PORT, () => {
  console.log(`ğŸš€ Server running on http://localhost:${PORT}`)
  console.log(`ğŸ¤– Enhanced YouTube video analysis enabled!`)
  console.log(`ğŸ”‘ Gemini API: ${process.env.GEMINI_API_KEY ? 'âœ…' : 'âŒ'}`)
  console.log(`ğŸ“º YouTube API: ${process.env.YOUTUBE_API_KEY ? 'âœ…' : 'âŒ'}`)
  console.log(`ğŸ“Š Features: Enhanced captions + Metadata + AI analysis + Clean formatting`)
  console.log(`ğŸ‘¨â€ğŸ’» Developer: NGOY HENOCK MUKONKOLE`)
  console.log(`ğŸ“§ Contact: hhnk3693@gmail.com`)
  console.log(`ğŸ™ GitHub: https://github.com/HorizonHnk/Youtube-Summarizer.git`)
})